package test

import (
	"fmt"
	"testing"

	"github.com/karosown/katool-go/util/markdown"
)

func Test_HTML(t *testing.T) {
	html := markdown.ToHtml(test_md)
	fmt.Println(html)
}

func Test_TREE(t *testing.T) {
	tree := markdown.ToTree(test_md)
	fmt.Println(tree)
}
func Test_MARKDOWN(t *testing.T) {
	tree := markdown.ToTree(test_md)
	toMarkdown := tree.ToMarkdown()
	fmt.Println(toMarkdown)
}
func Test_TREE2HTML(t *testing.T) {
	tree := markdown.ToTree(test_md)
	html := tree.ToHtml()
	fmt.Println(html)
}

const test_md = "# Katool-Go\n\n<div align=\"center\">\n\n<img src=\"logo.png\" alt=\"Katool-Go Logo\" width=\"400\">\n\n<h1>🛠️ Katool-Go</h1>\n\n<p>\n  <a href=\"https://pkg.go.dev/github.com/karosown/katool-go\"><img src=\"https://pkg.go.dev/badge/github.com/karosown/katool-go.svg\" alt=\"Go Reference\"></a>\n  <a href=\"https://goreportcard.com/report/github.com/karosown/katool-go\"><img src=\"https://goreportcard.com/badge/github.com/karosown/katool-go\" alt=\"Go Report Card\"></a>\n  <a href=\"https://github.com/karosown/katool-go/releases\"><img src=\"https://img.shields.io/github/v/release/karosown/katool-go\" alt=\"GitHub release\"></a>\n  <a href=\"https://github.com/karosown/katool-go/blob/main/LICENSE\"><img src=\"https://img.shields.io/github/license/karosown/katool-go\" alt=\"License\"></a>\n  <a href=\"https://golang.org/dl/\"><img src=\"https://img.shields.io/github/go-mod/go-version/karosown/katool-go\" alt=\"Go Version\"></a>\n</p>\n\n<b><i>一个功能丰富的 Go 工具库，借鉴 Java 生态优秀设计，为 Go 开发提供全方位支持</i></b>\n\n<p>\n  <a href=\"README.md\">🇨🇳 中文</a> |\n  <a href=\"README_EN.md\">🇺🇸 English</a>\n</p>\n\n</div>\n\n<hr>\n\n## 📋 目录\n\n- [📝 简介](#简介)\n- [✨ 特性](#特性)\n- [📦 安装](#安装)\n- [🚀 快速开始](#快速开始)\n- [🔧 核心模块](#核心模块)\n  - [📚 容器与集合](#容器与集合)\n    - [Optional 可选值容器](#optional-可选值容器)\n  - [🌊 流式处理](#流式处理)\n  - [🔄 数据转换](#数据转换)\n  - [💉 依赖注入](#依赖注入)\n  - [🔒 并发控制](#并发控制)\n  - [🕸️ Web爬虫](#web爬虫)\n  - [📁 文件操作](#文件操作)\n  - [💾 数据库支持](#数据库支持)\n  - [🌐 网络通信](#网络通信)\n  - [📝 日志系统](#日志系统)\n  - [⚙️ 算法工具](#算法工具)\n  - [🔤 文本处理](#文本处理)\n  - [⚡ 规则引擎](#规则引擎)\n  - [🧰 辅助工具](#辅助工具)\n- [💡 最佳实践](#最佳实践)\n- [👥 贡献指南](#贡献指南)\n- [📄 许可证](#许可证)\n\n<hr>\n\n## 📝 简介\n\n**Katool-Go** 是一个现代化的 Go 语言综合工具库，专为提高开发效率和代码质量而设计。它借鉴了 Java 生态系统中的成熟设计模式，同时充分利用 Go 语言的现代特性，如泛型、协程等，为开发者提供了一套完整的工具解决方案。\n\n本库采用**模块化、类型安全、高性能**的设计理念，适用于各种规模的 Go 项目，从微服务到大型企业应用，都能提供强有力的支持。\n\n### 🎯 设计目标\n\n- **类型安全**：充分利用 Go 1.18+ 泛型特性，提供类型安全的 API\n- **性能优异**：内置并发优化，充分发挥 Go 语言性能优势\n- **易于使用**：提供类似 Java Stream API 的链式操作，降低学习成本\n- **生产就绪**：完整的错误处理、日志系统和测试覆盖\n\n<hr>\n\n## ✨ 特性\n\nKatool-Go 提供以下核心特性：\n\n<table>\n  <tr>\n    <td><b>🌊 流式处理</b></td>\n    <td>类似 Java 8 Stream API 的链式操作，支持并行处理、map/filter/reduce/collect 等完整操作集</td>\n  </tr>\n  <tr>\n    <td><b>📚 容器与集合</b></td>\n    <td>增强的集合类型：Map、SafeMap、SortedMap、HashBasedMap、Optional 等，全部支持泛型</td>\n  </tr>\n  <tr>\n    <td><b>💉 依赖注入</b></td>\n    <td>轻量级 IOC 容器，支持组件注册、获取和生命周期管理，简化依赖管理</td>\n  </tr>\n  <tr>\n    <td><b>🔒 并发控制</b></td>\n    <td>LockSupport（类似Java的park/unpark）、同步锁封装等协程控制工具</td>\n  </tr>\n  <tr>\n    <td><b>🔄 数据转换</b></td>\n    <td>结构体属性复制、类型转换、文件导出（CSV/JSON）、序列化等全方位数据处理</td>\n  </tr>\n  <tr>\n    <td><b>🕸️ Web爬虫</b></td>\n    <td>智能内容提取、Chrome渲染支持、RSS订阅解析等完整爬虫解决方案</td>\n  </tr>\n  <tr>\n    <td><b>📁 文件操作</b></td>\n    <td>文件下载器、序列化工具、路径处理等文件系统操作</td>\n  </tr>\n  <tr>\n    <td><b>💾 数据库支持</b></td>\n    <td>MongoDB 增强工具、分页查询器等数据库操作简化</td>\n  </tr>\n  <tr>\n    <td><b>🌐 网络通信</b></td>\n    <td>现代化 HTTP 客户端、OAuth2 支持、SSE 实时通信、RESTful API 封装</td>\n  </tr>\n  <tr>\n    <td><b>📝 日志系统</b></td>\n    <td>结构化日志、链式构建、多级别输出、自定义格式化等完整日志方案</td>\n  </tr>\n  <tr>\n    <td><b>⚙️ 算法工具</b></td>\n    <td>有序数组合并、多种哈希计算、数据结构算法等实用算法集</td>\n  </tr>\n  <tr>\n    <td><b>🔤 文本处理</b></td>\n    <td>中文分词（jieba）、词频统计、文本分析、语言检测等NLP工具</td>\n  </tr>\n  <tr>\n    <td><b>⚡ 规则引擎</b></td>\n    <td>灵活的业务规则处理、规则链构建、中间件支持等企业级规则管理</td>\n  </tr>\n  <tr>\n    <td><b>🧰 辅助工具</b></td>\n    <td>日期处理、随机数生成、调试工具、系统工具等开发辅助功能</td>\n  </tr>\n</table>\n\n<hr>\n\n## 📦 安装\n\n使用 `go get` 安装最新版本：\n\n```bash\ngo get -u github.com/karosown/katool-go\n```\n\n> ⚠️ **系统要求**\n> - Go 版本 >= 1.23.1\n> - 支持泛型特性\n> - 推荐使用最新版本以获得最佳性能\n\n<hr>\n\n## 🚀 快速开始\n\n下面是几个核心功能的快速示例，展示 Katool-Go 的强大能力：\n\n<details open>\n<summary><b>🌊 流式处理 - Java风格的链式操作</b></summary>\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/karosown/katool-go/container/stream\"\n\t\"github.com/karosown/katool-go/algorithm\"\n)\n\n// 定义用户结构\ntype User struct {\n\tName  string `json:\"name\"`\n\tAge   int    `json:\"age\"`\n\tSex   int    `json:\"sex\"`    // 0-女性，1-男性\n\tMoney int    `json:\"money\"`\n\tClass string `json:\"class\"`\n\tId    int    `json:\"id\"`\n}\n\nfunc main() {\n\tusers := []User{\n\t\t{Name: \"Alice\", Age: 25, Sex: 1, Money: 1000, Class: \"A\", Id: 1},\n\t\t{Name: \"Bob\", Age: 30, Sex: 0, Money: 1500, Class: \"B\", Id: 2},\n\t\t{Name: \"Charlie\", Age: 35, Sex: 0, Money: 2000, Class: \"A\", Id: 3},\n\t\t{Name: \"David\", Age: 40, Sex: 1, Money: 2500, Class: \"B\", Id: 4},\n\t}\n\t\n\t// 创建并行流\n\tuserStream := stream.ToStream(&users).Parallel()\n\t\n\t// 链式操作：过滤 -> 排序 -> 统计\n\tadultUsers := userStream.\n\t\tFilter(func(u User) bool { \n\t\t\treturn u.Age >= 30 \n\t\t}).\n\t\tSort(func(a, b User) bool { \n\t\t\treturn a.Money > b.Money  // 按收入降序\n\t\t}).\n\t\tToList()\n\t\n\tfmt.Printf(\"30岁以上用户（按收入排序）: %+v\\n\", adultUsers)\n\t\n\t// 聚合计算：总收入\n\ttotalMoney := userStream.Reduce(int64(0), \n\t\tfunc(sum any, u User) any { \n\t\t\treturn sum.(int64) + int64(u.Money) \n\t\t}, \n\t\tfunc(sum1, sum2 any) any {\n\t\t\treturn sum1.(int64) + sum2.(int64)\n\t\t})\n\tfmt.Printf(\"总收入: %d\\n\", totalMoney)\n\t\n\t// 分组统计：按班级分组\n\tgroups := stream.ToStream(&users).GroupBy(func(u User) any {\n\t\treturn u.Class\n\t})\n\t\n\tfor class, members := range groups {\n\t\tfmt.Printf(\"班级 %s: %d人\\n\", class, len(members))\n\t}\n\t\n\t// 去重操作（基于JSON序列化）\n\tuniqueUsers := userStream.DistinctBy(algorithm.HASH_WITH_JSON_MD5).ToList()\n\tfmt.Printf(\"去重后用户数: %d\\n\", len(uniqueUsers))\n\t\n\t// 转换为映射\n\tuserMap := stream.ToStream(&users).ToMap(\n\t\tfunc(index int, u User) any { return u.Id },\n\t\tfunc(index int, u User) any { return u.Name },\n\t)\n\tfmt.Printf(\"用户ID->姓名映射: %+v\\n\", userMap)\n}\n```\n</details>\n\n<details>\n<summary><b>📚 增强集合 - 类型安全的容器</b></summary>\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"encoding/json\"\n\t\"github.com/karosown/katool-go/container/xmap\"\n\t\"github.com/karosown/katool-go/container/optional\"\n)\n\nfunc main() {\n\t// 1. 基础Map - 泛型支持\n\tuserMap := xmap.NewMap[string, User]()\n\tuserMap.Set(\"alice\", User{Name: \"Alice\", Age: 25})\n\tuserMap.Set(\"bob\", User{Name: \"Bob\", Age: 30})\n\t\n\tif user, exists := userMap.Get(\"alice\"); exists {\n\t\tfmt.Printf(\"找到用户: %+v\\n\", user)\n\t}\n\t\n\t// 2. 线程安全Map - 并发场景\n\tsafeMap := xmap.NewSafeMap[string, int]()\n\t\n\t// 原子操作：获取或存储\n\tvalue, loaded := safeMap.LoadOrStore(\"counter\", 1)\n\tfmt.Printf(\"计数器值: %d, 是否已存在: %v\\n\", value, loaded)\n\t\n\t// 原子操作：获取并删除\n\tvalue, exists := safeMap.LoadAndDelete(\"counter\")\n\tfmt.Printf(\"删除的值: %d, 是否存在: %v\\n\", value, exists)\n\t\n\t// 3. 有序Map - 按键排序，支持JSON序列化\n\tsortedMap := xmap.NewSortedMap[string, string]()\n\tsortedMap.Set(\"3\", \"three\")\n\tsortedMap.Set(\"1\", \"one\")\n\tsortedMap.Set(\"2\", \"two\")\n\t\n\tjsonBytes, _ := json.Marshal(sortedMap) \n\tfmt.Printf(\"有序JSON: %s\\n\", string(jsonBytes))  // 按键排序输出\n\t\n\t// 4. 双层键映射\n\tdbMap := xmap.NewHashBasedMap[string, int, User]()\n\tdbMap.Set(\"users\", 1, User{Name: \"Alice\", Age: 25})\n\tdbMap.Set(\"users\", 2, User{Name: \"Bob\", Age: 30})\n\tdbMap.Set(\"admins\", 1, User{Name: \"Admin\", Age: 40})\n\t\n\tif user, exists := dbMap.Get(\"users\", 1); exists {\n\t\tfmt.Printf(\"用户表中ID=1的用户: %+v\\n\", user)\n\t}\n\t\n\t// 5. Optional - 避免空指针\n\topt := optional.Of(\"Hello World\")\n\topt.IfPresent(func(s string) {\n\t\tfmt.Printf(\"Optional值: %s\\n\", s)\n\t})\n\t\n\temptyOpt := optional.Empty[string]()\n\tdefaultValue := emptyOpt.OrElse(\"默认值\")\n\tfmt.Printf(\"空Optional的默认值: %s\\n\", defaultValue)\n}\n```\n</details>\n\n<details>\n<summary><b>🔒 并发控制 - 协程同步</b></summary>\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\t\"sync\"\n\t\"github.com/karosown/katool-go/lock\"\n\t\"github.com/karosown/katool-go/container/stream\"\n)\n\nfunc main() {\n\t// 1. LockSupport - 类似Java的park/unpark\n\tfmt.Println(\"=== LockSupport 示例 ===\")\n\tls := lock.NewLockSupport()\n\t\n\tgo func() {\n\t\tfmt.Println(\"子协程：准备阻塞等待...\")\n\t\tls.Park()  // 阻塞直到被唤醒\n\t\tfmt.Println(\"子协程：被成功唤醒！\")\n\t}()\n\t\n\ttime.Sleep(time.Second)\n\tfmt.Println(\"主协程：发送唤醒信号\")\n\tls.Unpark()  // 唤醒阻塞的协程\n\t\n\ttime.Sleep(100 * time.Millisecond)  // 等待输出\n\t\n\t// 2. 批量协程管理\n\tfmt.Println(\"\\n=== 批量协程管理 ===\")\n\tsupports := make([]*lock.LockSupport, 5)\n\tfor i := 0; i < 5; i++ {\n\t\tsupports[i] = lock.NewLockSupport()\n\t\tidx := i\n\t\tgo func() {\n\t\t\tfmt.Printf(\"协程 %d: 等待唤醒\\n\", idx)\n\t\t\tsupports[idx].Park()\n\t\t\tfmt.Printf(\"协程 %d: 被唤醒\\n\", idx)\n\t\t}()\n\t}\n\t\n\ttime.Sleep(500 * time.Millisecond)\n\t\n\t// 使用流式API批量唤醒\n\tstream.ToStream(&supports).ForEach(func(ls *lock.LockSupport) {\n\t\tls.Unpark()\n\t\ttime.Sleep(100 * time.Millisecond)  // 依次唤醒\n\t})\n\t\n\t// 3. 同步代码块\n\tfmt.Println(\"\\n=== 同步代码块 ===\")\n\tvar counter int\n\tvar mutex sync.Mutex\n\t\n\t// 传统方式 vs 封装方式\n\tlock.Synchronized(&mutex, func() {\n\t\tcounter++\n\t\tfmt.Printf(\"同步块中的计数器: %d\\n\", counter)\n\t})\n\t\n\t// 带返回值的同步\n\tresult := lock.SynchronizedT(&mutex, func() string {\n\t\treturn fmt.Sprintf(\"最终计数: %d\", counter)\n\t})\n\tfmt.Println(result)\n\t\n\ttime.Sleep(100 * time.Millisecond)\n}\n```\n</details>\n\n<details>\n<summary><b>🔄 数据转换 - 全方位数据处理</b></summary>\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/karosown/katool-go/convert\"\n)\n\n// 源结构体\ntype UserEntity struct {\n\tID       int    `json:\"id\"`\n\tName     string `json:\"name\"`\n\tAge      int    `json:\"age\"`\n\tEmail    string `json:\"email\"`\n\tCreateAt string `json:\"create_at\"`\n}\n\n// 目标DTO\ntype UserDTO struct {\n\tID       int    `json:\"id\"`\n\tName     string `json:\"name\"`\n\tAge      int    `json:\"age\"`\n\tEmail    string `json:\"email\"`\n\tStatus   string `json:\"status\"`  // 新增字段\n}\n\nfunc main() {\n\tusers := []UserEntity{\n\t\t{ID: 1, Name: \"Alice\", Age: 25, Email: \"alice@example.com\", CreateAt: \"2024-01-01\"},\n\t\t{ID: 2, Name: \"Bob\", Age: 30, Email: \"bob@example.com\", CreateAt: \"2024-01-02\"},\n\t\t{ID: 3, Name: \"Charlie\", Age: 35, Email: \"charlie@example.com\", CreateAt: \"2024-01-03\"},\n\t}\n\t\n\t// 1. 属性复制（同名字段自动复制）\n\tfmt.Println(\"=== 属性复制 ===\")\n\tsourceUser := users[0]\n\ttargetDTO := &UserDTO{Status: \"Active\"}  // 预设新字段\n\t\n\tresult, err := convert.CopyProperties(sourceUser, targetDTO)\n\tif err == nil {\n\t\tfmt.Printf(\"复制结果: %+v\\n\", result)\n\t}\n\t\n\t// 2. 批量转换\n\tfmt.Println(\"\\n=== 批量转换 ===\")\n\tdtos := convert.Convert(users, func(user UserEntity) UserDTO {\n\t\treturn UserDTO{\n\t\t\tID:     user.ID,\n\t\t\tName:   user.Name,\n\t\t\tAge:    user.Age,\n\t\t\tEmail:  user.Email,\n\t\t\tStatus: \"Active\",\n\t\t}\n\t})\n\tfmt.Printf(\"转换后的DTO列表: %+v\\n\", dtos)\n\t\n\t// 3. 类型转换\n\tfmt.Println(\"\\n=== 类型转换 ===\")\n\tfmt.Printf(\"整数转字符串: %s\\n\", convert.ToString(123))\n\tfmt.Printf(\"布尔转字符串: %s\\n\", convert.ToString(true))\n\tfmt.Printf(\"切片转字符串: %s\\n\", convert.ToString([]int{1, 2, 3}))\n\t\n\t// 4. 类型擦除和恢复\n\tfmt.Println(\"\\n=== 类型擦除和恢复 ===\")\n\tanySlice := convert.ToAnySlice(users)\n\tfmt.Printf(\"类型擦除后长度: %d\\n\", len(anySlice))\n\t\n\trecoveredUsers := convert.FromAnySlice[UserEntity](anySlice)\n\tfmt.Printf(\"恢复类型后第一个用户: %+v\\n\", recoveredUsers[0])\n\t\n\t// 5. 文件导出\n\tfmt.Println(\"\\n=== 文件导出 ===\")\n\t// 导出为JSON文件\n\terr = convert.StructToJsonFile(users, \"users.json\")\n\tif err == nil {\n\t\tfmt.Println(\"成功导出JSON文件: users.json\")\n\t}\n\t\n\t// 导出为CSV文件（需要csv标签）\n\ttype UserCSV struct {\n\t\tID   int    `csv:\"用户ID\"`\n\t\tName string `csv:\"姓名\"`\n\t\tAge  int    `csv:\"年龄\"`\n\t}\n\t\n\tcsvUsers := convert.Convert(users, func(u UserEntity) UserCSV {\n\t\treturn UserCSV{ID: u.ID, Name: u.Name, Age: u.Age}\n\t})\n\t\n\terr = convert.StructToCSV(csvUsers, \"users.csv\")\n\tif err == nil {\n\t\tfmt.Println(\"成功导出CSV文件: users.csv\")\n\t}\n}\n```\n</details>\n\n<details>\n<summary><b>📚 Optional 容器 - 安全处理空值</b></summary>\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"github.com/karosown/katool-go/container/optional\"\n)\n\nfunc main() {\n\t// 1. 基础用法：安全处理可能为空的值\n\tfmt.Println(\"=== Optional 基础用法 ===\")\n\t\n\t// 创建包含值的Optional\n\tnameOpt := optional.Of(\"张三\")\n\tnameOpt.IfPresent(func(name string) {\n\t\tfmt.Printf(\"用户名: %s\\n\", name)\n\t})\n\t\n\t// 处理空值情况\n\temptyOpt := optional.Empty[string]()\n\tusername := emptyOpt.OrElse(\"匿名用户\")\n\tfmt.Printf(\"用户名（带默认值）: %s\\n\", username)\n\t\n\t// 2. 函数式链式操作\n\tfmt.Println(\"\\n=== 链式操作 ===\")\n\t\n\t// 用户输入处理链\n\tuserInput := \"  HELLO WORLD  \"\n\tprocessedInput := optional.MapTyped(optional.Of(userInput), strings.TrimSpace).\n\t\tFilter(func(s string) bool { return len(s) > 0 }).         // 过滤空字符串\n\t\tMap(func(s any) any { return strings.ToLower(s.(string)) }). // 转小写\n\t\tOrElse(\"无效输入\")\n\t\n\tfmt.Printf(\"处理后的输入: %s\\n\", processedInput)\n\t\n\t// 3. 字符串专用处理\n\tfmt.Println(\"\\n=== 字符串专用处理 ===\")\n\t\n\t// StringOptional 链式处理\n\tresult := optional.NewStringOptional(\"  hello world  \").\n\t\tTrimSpace().                    // 去除空格\n\t\tFilterNonEmpty().              // 过滤空字符串\n\t\tOrElse(\"空字符串\")\n\t\n\tfmt.Printf(\"字符串处理结果: %s\\n\", result)\n\t\n\t// 4. 配置值处理\n\tfmt.Println(\"\\n=== 配置值处理 ===\")\n\t\n\t// 模拟从环境变量获取配置\n\tgetConfig := func(key string) optional.Optional[string] {\n\t\tconfigs := map[string]string{\n\t\t\t\"database_url\": \"postgres://localhost:5432/mydb\",\n\t\t\t\"redis_url\":    \"\",  // 空值\n\t\t}\n\t\treturn optional.OfNullable(configs[key])\n\t}\n\t\n\t// 获取数据库配置，带默认值\n\tdbUrl := getConfig(\"database_url\").OrElse(\"sqlite://memory\")\n\tfmt.Printf(\"数据库URL: %s\\n\", dbUrl)\n\t\n\t// 获取Redis配置，空值处理\n\tredisUrl := getConfig(\"redis_url\").OrElse(\"redis://localhost:6379\")\n\tfmt.Printf(\"Redis URL: %s\\n\", redisUrl)\n\t\n\t// 5. 用户验证链\n\tfmt.Println(\"\\n=== 用户验证链 ===\")\n\t\n\ttype User struct {\n\t\tName  string\n\t\tAge   int\n\t\tEmail string\n\t}\n\t\n\tvalidateUser := func(user User) optional.Optional[User] {\n\t\treturn optional.Of(user).\n\t\t\tFilter(func(u User) bool { return u.Name != \"\" }).        // 验证姓名\n\t\t\tFilter(func(u User) bool { return u.Age >= 18 }).         // 验证年龄\n\t\t\tFilter(func(u User) bool { return strings.Contains(u.Email, \"@\") }) // 验证邮箱\n\t}\n\t\n\t// 测试有效用户\n\tvalidUser := User{Name: \"张三\", Age: 25, Email: \"zhangsan@example.com\"}\n\tresult1 := validateUser(validUser)\n\tresult1.IfPresentOrElse(\n\t\tfunc(u User) { fmt.Printf(\"验证通过: %+v\\n\", u) },\n\t\tfunc() { fmt.Println(\"验证失败\") },\n\t)\n\t\n\t// 测试无效用户\n\tinvalidUser := User{Name: \"\", Age: 16, Email: \"invalid-email\"}\n\tresult2 := validateUser(invalidUser)\n\tresult2.IfPresentOrElse(\n\t\tfunc(u User) { fmt.Printf(\"验证通过: %+v\\n\", u) },\n\t\tfunc() { fmt.Println(\"验证失败\") },\n\t)\n\t\n\t// 6. 条件工具函数\n\tfmt.Println(\"\\n=== 条件工具函数 ===\")\n\t\n\tisVIP := true\n\tuserType := optional.IsTrue(isVIP, \"VIP用户\", \"普通用户\")\n\tfmt.Printf(\"用户类型: %s\\n\", userType)\n\t\n\t// 根据条件执行不同函数\n\tmessage := optional.IsTrueByFunc(isVIP,\n\t\tfunc() string { return \"欢迎VIP用户，享受专属服务！\" },\n\t\tfunc() string { return \"欢迎使用我们的服务！\" },\n\t)\n\tfmt.Printf(\"欢迎消息: %s\\n\", message)\n}\n```\n</details>\n\n<details>\n<summary><b>⚡ 规则引擎 - 灵活的业务逻辑</b></summary>\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\t\"github.com/karosown/katool-go/ruleengine\"\n)\n\ntype User struct {\n\tID       int       `json:\"id\"`\n\tName     string    `json:\"name\"`\n\tAge      int       `json:\"age\"`\n\tEmail    string    `json:\"email\"`\n\tVIPLevel int       `json:\"vip_level\"`\n\tBalance  float64   `json:\"balance\"`\n\tIDCard   string    `json:\"id_card\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n}\n\nfunc main() {\n\t// 1. 创建规则引擎\n\tfmt.Println(\"=== 规则引擎基础用法 ===\")\n\t\n\tengine := ruleengine.NewRuleEngine[User]()\n\t\n\t// 2. 注册验证规则\n\tengine.RegisterRule(\"validate_basic_info\",\n\t\tfunc(user User, _ any) bool { return true },\n\t\tfunc(user User, _ any) (User, any, error) {\n\t\t\tif user.Name == \"\" {\n\t\t\t\treturn user, \"用户名不能为空\", ruleengine.EOF\n\t\t\t}\n\t\t\tif len(user.Name) < 2 {\n\t\t\t\treturn user, \"用户名太短\", ruleengine.EOF\n\t\t\t}\n\t\t\treturn user, \"基础信息验证通过\", nil\n\t\t},\n\t)\n\t\n\t// 3. 年龄检查规则（含流程控制）\n\tengine.RegisterRule(\"check_age\",\n\t\tfunc(user User, _ any) bool { return true },\n\t\tfunc(user User, _ any) (User, any, error) {\n\t\t\tif user.Age < 13 {\n\t\t\t\treturn user, \"用户年龄过小\", ruleengine.EOF // 立即终止\n\t\t\t} else if user.Age < 18 {\n\t\t\t\treturn user, \"未成年用户\", ruleengine.FALLTHROUGH // 跳过成年用户逻辑\n\t\t\t}\n\t\t\treturn user, \"成年用户\", nil\n\t\t},\n\t)\n\t\n\t// 4. 成年用户身份验证（未成年用户会跳过）\n\tengine.RegisterRule(\"adult_identity_check\",\n\t\tfunc(user User, _ any) bool { return user.Age >= 18 },\n\t\tfunc(user User, _ any) (User, any, error) {\n\t\t\tif user.IDCard == \"\" {\n\t\t\t\treturn user, \"成年用户需要身份证\", ruleengine.EOF\n\t\t\t}\n\t\t\treturn user, \"身份验证完成\", nil\n\t\t},\n\t)\n\t\n\t// 5. VIP特权检查\n\tengine.RegisterRule(\"vip_privilege_check\",\n\t\tfunc(user User, _ any) bool { return user.VIPLevel > 0 },\n\t\tfunc(user User, _ any) (User, any, error) {\n\t\t\tif user.VIPLevel >= 3 {\n\t\t\t\tuser.Balance += 100.0  // VIP3以上赠送余额\n\t\t\t\treturn user, \"VIP特权已激活\", nil\n\t\t\t} else if user.VIPLevel >= 1 {\n\t\t\t\tuser.Balance += 50.0   // VIP1-2赠送部分余额\n\t\t\t\treturn user, \"VIP福利已发放\", nil\n\t\t\t}\n\t\t\treturn user, \"普通用户\", nil\n\t\t},\n\t)\n\t\n\t// 6. 最终注册\n\tengine.RegisterRule(\"complete_registration\",\n\t\tfunc(user User, _ any) bool { return true },\n\t\tfunc(user User, _ any) (User, any, error) {\n\t\t\tif user.ID == 0 {\n\t\t\t\tuser.ID = int(time.Now().Unix()) // 生成ID\n\t\t\t}\n\t\t\tuser.CreatedAt = time.Now()\n\t\t\treturn user, \"注册完成\", nil\n\t\t},\n\t)\n\t\n\t// 7. 添加日志中间件\n\tengine.AddMiddleware(func(data User, next func(User) (User, any, error)) (User, any, error) {\n\t\tfmt.Printf(\"  → 处理用户: %s (年龄: %d)\\n\", data.Name, data.Age)\n\t\tresult, info, err := next(data)\n\t\tif err == ruleengine.EOF {\n\t\t\tfmt.Printf(\"  ✖ 流程终止: %v\\n\", info)\n\t\t} else if err == ruleengine.FALLTHROUGH {\n\t\t\tfmt.Printf(\"  ⚡ 规则跳过: %v\\n\", info)\n\t\t} else if err == nil {\n\t\t\tfmt.Printf(\"  ✓ 执行成功: %v\\n\", info)\n\t\t} else {\n\t\t\tfmt.Printf(\"  ✗ 执行失败: %v\\n\", err)\n\t\t}\n\t\treturn result, info, err\n\t})\n\t\n\t// 8. 构建注册流程链\n\t_, err := engine.NewBuilder(\"user_registration\").\n\t\tAddRule(\"validate_basic_info\").\n\t\tAddRule(\"check_age\").\n\t\tAddRule(\"adult_identity_check\").\n\t\tAddRule(\"vip_privilege_check\").\n\t\tAddRule(\"complete_registration\").\n\t\tBuild()\n\t\n\tif err != nil {\n\t\tfmt.Printf(\"构建规则链失败: %v\\n\", err)\n\t\treturn\n\t}\n\t\n\t// 9. 测试不同场景\n\tfmt.Println(\"\\n=== 测试场景 1: 正常成年VIP用户 ===\")\n\tadultVIP := User{\n\t\tName:     \"张三\",\n\t\tAge:      25,\n\t\tEmail:    \"zhangsan@example.com\",\n\t\tVIPLevel: 3,\n\t\tIDCard:   \"123456789012345678\",\n\t\tBalance:  0,\n\t}\n\tresult1 := engine.Execute(\"user_registration\", adultVIP)\n\tfmt.Printf(\"最终结果: ID=%d, 余额=%.2f\\n\", result1.Data.ID, result1.Data.Balance)\n\t\n\tfmt.Println(\"\\n=== 测试场景 2: 未成年用户（跳过身份验证）===\")\n\tminor := User{\n\t\tName:     \"李四\",\n\t\tAge:      16,\n\t\tEmail:    \"lisi@example.com\",\n\t\tVIPLevel: 1,\n\t\tBalance:  0,\n\t}\n\tresult2 := engine.Execute(\"user_registration\", minor)\n\tfmt.Printf(\"最终结果: ID=%d, 余额=%.2f\\n\", result2.Data.ID, result2.Data.Balance)\n\t\n\tfmt.Println(\"\\n=== 测试场景 3: 年龄过小（立即终止）===\")\n\tchild := User{\n\t\tName:     \"王五\",\n\t\tAge:      10,\n\t\tEmail:    \"wangwu@example.com\",\n\t\tVIPLevel: 0,\n\t\tBalance:  0,\n\t}\n\tresult3 := engine.Execute(\"user_registration\", child)\n\tif result3.Error != nil {\n\t\tfmt.Printf(\"注册失败: %v\\n\", result3.Error)\n\t}\n\t\n\tfmt.Println(\"\\n=== 测试场景 4: 批量处理多个用户 ===\")\n\tusers := []User{\n\t\t{Name: \"用户A\", Age: 25, VIPLevel: 2, IDCard: \"111111111111111111\"},\n\t\t{Name: \"用户B\", Age: 17, VIPLevel: 1},\n\t\t{Name: \"\", Age: 30, VIPLevel: 0},  // 无效用户名\n\t}\n\t\n\tfor i, user := range users {\n\t\tfmt.Printf(\"\\n--- 处理用户 %d ---\\n\", i+1)\n\t\tresult := engine.Execute(\"user_registration\", user)\n\t\tif result.Error != nil && result.Error != ruleengine.EOF && result.Error != ruleengine.FALLTHROUGH {\n\t\t\tfmt.Printf(\"处理失败: %v\\n\", result.Error)\n\t\t} else {\n\t\t\tfmt.Printf(\"处理完成: ID=%d\\n\", result.Data.ID)\n\t\t}\n\t}\n}\n```\n</details>\n\n<hr>\n\n## 🔧 核心模块\n\n### 📚 容器与集合\n\nKatool-Go 提供了丰富的容器和集合类型，全部支持泛型，提供类型安全的操作。\n\n#### Optional 可选值容器\n\nOptional 是一个用于安全处理可能为空值的容器类型，灵感来自 Java 的 Optional 类，提供类型安全的空值处理机制。\n\n##### 🚀 基础用法\n\n```go\nimport \"github.com/karosown/katool-go/container/optional\"\n\n// 创建包含值的Optional\nopt := optional.Of(\"Hello World\")\n\n// 创建空的Optional\nemptyOpt := optional.Empty[string]()\n\n// 根据值是否为零值创建Optional\nnullableOpt := optional.OfNullable(\"\")  // 空字符串会创建空Optional\n```\n\n##### 🔍 安全检查和获取\n\n```go\n// 安全检查和获取\nif opt.IsPresent() {\n    value := opt.Get()\n    fmt.Println(\"值存在:\", value)\n}\n\n// 检查是否为空\nif emptyOpt.IsEmpty() {\n    fmt.Println(\"Optional为空\")\n}\n\n// 提供默认值的几种方式\ndefaultValue := emptyOpt.OrElse(\"默认值\")\nlazyDefault := emptyOpt.OrElseGet(func() string {\n    return \"延迟计算的默认值\"\n})\nsafeValue := opt.OrElsePanic(\"Optional不能为空!\")\n```\n\n##### ⚡ 函数式操作\n\n```go\n// 条件执行 - 有值时执行\nopt.IfPresent(func(v string) {\n    fmt.Println(\"处理值:\", v)\n})\n\n// 双分支执行 - 有值执行第一个函数，无值执行第二个\nopt.IfPresentOrElse(\n    func(v string) { fmt.Println(\"有值:\", v) },\n    func() { fmt.Println(\"无值\") },\n)\n\n// 过滤操作\nfiltered := opt.Filter(func(s string) bool {\n    return len(s) > 5\n})\n\n// 类型安全的映射（推荐）\nresult := optional.MapTyped(optional.Of(\"  hello  \"), strings.TrimSpace).\n    Filter(func(s string) bool { return len(s) > 0 }).\n    OrElse(\"空字符串\")\n```\n\n##### 🔤 字符串处理专用\n\n为了更好地支持字符串处理，提供了专用的 StringOptional：\n\n```go\n// 专用的StringOptional进行链式字符串处理\nresult := optional.NewStringOptional(\"  hello  \").\n    TrimSpace().                    // 去除空格\n    FilterNonEmpty().              // 过滤空字符串\n    OrElse(\"空字符串\")             // 提供默认值\n\nfmt.Println(\"处理结果:\", result) // 输出: 处理结果: hello\n```\n\n##### 🛠️ 实用工具函数\n\n```go\n// 根据条件返回不同的值\nenabled := optional.IsTrue(condition, \"启用\", \"禁用\")\n\n// 根据条件调用不同的函数\nresult := optional.IsTrueByFunc(condition, \n    func() string { return \"功能已启用\" },\n    func() string { return \"功能已禁用\" },\n)\n\n// 根据函数条件调用不同的函数\nresult := optional.FuncIsTrueByFunc(\n    func() bool { return someComplexCondition() },\n    enabledFunc,\n    disabledFunc,\n)\n```\n\n##### 📝 实用示例\n\n**用户输入处理**\n```go\nfunc processUserInput(input string) string {\n    return optional.MapTyped(optional.Of(input), strings.TrimSpace).\n        Filter(func(s string) bool { return len(s) > 0 }).\n        Map(func(s any) any { return strings.ToLower(s.(string)) }).\n        OrElse(\"无效输入\").(string)\n}\n```\n\n**配置值处理**\n```go\nfunc getConfig(key string) optional.Optional[string] {\n    if value := os.Getenv(key); value != \"\" {\n        return optional.Of(value)\n    }\n    return optional.Empty[string]()\n}\n\n// 使用\ndbUrl := getConfig(\"DATABASE_URL\").OrElse(\"sqlite://default.db\")\n```\n\n**用户验证链式处理**\n```go\nfunc validateUser(user User) optional.Optional[User] {\n    return optional.Of(user).\n        Filter(func(u User) bool { return u.Name != \"\" }).\n        Filter(func(u User) bool { return u.Age >= 18 }).\n        Filter(func(u User) bool { return u.Email != \"\" })\n}\n\n// 使用\nvalidUser := validateUser(user).OrElsePanic(\"用户验证失败\")\n```\n\n##### 📋 API 参考\n\n**核心方法：**\n- `Of[T](value T)` - 创建包含值的Optional\n- `Empty[T]()` - 创建空Optional\n- `OfNullable[T](value T)` - 根据零值创建Optional\n\n**检查方法：**\n- `IsPresent()` - 检查是否有值\n- `IsEmpty()` - 检查是否为空\n\n**获取方法：**\n- `Get()` - 获取值（空时panic）\n- `OrElse(T)` - 提供默认值\n- `OrElseGet(func() T)` - 延迟计算默认值\n- `OrElsePanic(string)` - 空时panic并显示消息\n\n**函数式方法：**\n- `IfPresent(func(T))` - 条件执行\n- `IfPresentOrElse(func(T), func())` - 双分支执行\n- `Filter(func(T) bool)` - 过滤\n- `Map(func(T) any)` - 映射（实例方法）\n- `MapTyped[T,R](Optional[T], func(T) R)` - 类型安全映射\n\n##### ⚠️ 注意事项\n\n1. **类型安全**: 使用 `MapTyped` 进行类型安全的映射操作\n2. **链式调用**: 实例方法支持链式调用，但要注意类型转换\n3. **性能**: Optional 会带来轻微的性能开销，在性能敏感的场景中谨慎使用\n4. **空指针**: Optional 本身不会为 nil，但内部值可能是零值\n\n### 🌊 流式处理\n\n提供类似 Java 8 Stream API 的强大流式处理能力，支持并行计算和链式操作。\n\n```go\nimport \"github.com/karosown/katool-go/container/stream\"\n\n// 并行流处理\nresults := stream.ToStream(&data).\n    Parallel().                               // 启用并行处理\n    Filter(func(item Item) bool { return item.IsValid() }).\n    Map(func(item Item) ProcessedItem { return item.Process() }).\n    Sort(func(a, b ProcessedItem) bool { return a.Priority > b.Priority }).\n    ToList()\n```\n\n### 🔄 数据转换\n\n强大的数据转换和结构体处理能力。\n\n```go\nimport \"github.com/karosown/katool-go/convert\"\n\n// 结构体复制\nvar dest DestStruct\nconvert.CopyStruct(&dest, &source)\n\n// 数据导出\nconvert.ExportToCSV(data, \"output.csv\")\nconvert.ExportToJSON(data, \"output.json\")\n```\n\n### 💉 依赖注入\n\n轻量级IOC容器，简化依赖管理。\n\n```go\nimport \"github.com/karosown/katool-go/container/ioc\"\n\n// 注册服务\ncontainer := ioc.NewContainer()\ncontainer.Register(\"userService\", &UserService{})\n\n// 获取服务\nuserSvc := container.Get(\"userService\").(*UserService)\n```\n\n### 🔒 并发控制\n\n提供类似Java的并发控制工具。\n\n```go\nimport \"github.com/karosown/katool-go/lock\"\n\n// LockSupport 类似Java的park/unpark\nlock.LockSupport.Park()        // 阻塞当前协程\nlock.LockSupport.Unpark(goroutineId) // 唤醒指定协程\n```\n\n### 🕸️ Web爬虫\n\n智能内容提取和网页爬取工具。\n\n```go\nimport \"github.com/karosown/katool-go/web_crawler\"\n\n// 内容提取\nextractor := web_crawler.NewContentExtractor()\ncontent := extractor.ExtractFromURL(\"https://example.com\")\n\n// Chrome渲染支持\nrenderer := web_crawler.NewChromeRenderer()\nhtml := renderer.RenderPage(\"https://spa-app.com\")\n```\n\n### 📁 文件操作\n\n完整的文件系统操作工具。\n\n```go\nimport \"github.com/karosown/katool-go/file\"\n\n// 文件下载\ndownloader := file.NewDownloader()\ndownloader.Download(\"https://example.com/file.zip\", \"./downloads/\")\n\n// 序列化操作\nfile.SerializeToFile(data, \"data.json\")\ndata := file.DeserializeFromFile[MyStruct](\"data.json\")\n```\n\n### 💾 数据库支持\n\nMongoDB等数据库操作增强。\n\n```go\nimport \"github.com/karosown/katool-go/db\"\n\n// MongoDB分页查询\npaginator := db.NewMongoPaginator(collection)\nresult := paginator.Page(1).Size(20).Find(filter)\n```\n\n### 🌐 网络通信\n\n现代化HTTP客户端和网络工具。\n\n```go\nimport \"github.com/karosown/katool-go/net/http/remote\"\n\n// 链式HTTP请求构建\nvar result APIResponse\nresp, err := remote.NewRemoteRequest(\"https://api.example.com\").\n    Headers(map[string]string{\"Authorization\": \"Bearer \" + token}).\n    QueryParam(map[string]string{\"page\": \"1\"}).\n    Method(\"GET\").\n    Url(\"/api/data\").\n    Build(&result)\n```\n\n### 📝 日志系统\n\n结构化日志和链式构建。\n\n```go\nimport \"github.com/karosown/katool-go/xlog\"\n\n// 结构化日志\nlogger := xlog.NewLogger().\n    WithField(\"service\", \"user-api\").\n    WithField(\"version\", \"1.0.0\")\n\nlogger.Info(\"用户登录成功\").\n    WithField(\"userId\", userId).\n    WithField(\"ip\", clientIP).\n    Log()\n```\n\n### ⚙️ 算法工具\n\n实用算法和数据结构。\n\n```go\nimport \"github.com/karosown/katool-go/algorithm\"\n\n// 有序数组合并\nmerged := algorithm.MergeSortedArrays(arr1, arr2)\n\n// 哈希计算\nhash := algorithm.ComputeHash(data)\n```\n\n### 🔤 文本处理\n\n中文分词和文本分析。\n\n```go\nimport \"github.com/karosown/katool-go/words\"\n\n// 中文分词\nsegmenter := words.NewJiebaSegmenter()\ntokens := segmenter.Cut(\"这是一个中文分词测试\", true)\n\n// 词频统计\ncounter := words.NewWordCounter()\nfrequencies := counter.Count(tokens)\n```\n\n### 🧰 辅助工具\n\n实用的开发辅助工具。\n\n```go\nimport \"github.com/karosown/katool-go/util\"\n\n// 日期处理\ndate := util.ParseDate(\"2023-12-25\")\nformatted := util.FormatDate(date, \"YYYY-MM-DD\")\n\n// 随机数生成\nrandomStr := util.RandomString(10)\nrandomInt := util.RandomInt(1, 100)\n```\n\n### ⚡ 规则引擎\n\n灵活强大的业务规则处理引擎，支持规则链、规则树和中间件机制。支持泛型、并发安全，提供EOF和FALLTHROUGH流程控制。\n\n#### 🚀 快速开始\n\n```go\nimport \"github.com/karosown/katool-go/ruleengine\"\n\n// 1. 创建规则引擎\nengine := ruleengine.NewRuleEngine[User]()\n\n// 2. 注册规则\nengine.RegisterRule(\"validate_age\",\n    func(user User, _ any) bool { return user.Age > 0 },  // 验证函数\n    func(user User, _ any) (User, any, error) {           // 执行函数\n        if user.Age < 18 {\n            return user, \"未成年用户\", nil\n        }\n        return user, \"成年用户\", nil\n    },\n)\n\n// 3. 构建规则链\nengine.NewBuilder(\"user_processing\").\n    AddRule(\"validate_age\").\n    Build()\n\n// 4. 执行规则\nuser := User{Name: \"张三\", Age: 25}\nresult := engine.Execute(\"user_processing\", user)\nfmt.Printf(\"处理结果: %v\\n\", result.Result)\n```\n\n#### 🛠️ 高级功能\n\n##### 中间件支持\n\n```go\n// 添加日志中间件\nengine.AddMiddleware(func(data User, next func(User) (User, any, error)) (User, any, error) {\n    fmt.Printf(\"执行前: %+v\\n\", data)\n    result, info, err := next(data)\n    fmt.Printf(\"执行后: %+v\\n\", result)\n    return result, info, err\n})\n\n// 添加性能监控中间件\nengine.AddMiddleware(func(data User, next func(User) (User, any, error)) (User, any, error) {\n    start := time.Now()\n    result, info, err := next(data)\n    fmt.Printf(\"执行耗时: %v\\n\", time.Since(start))\n    return result, info, err\n})\n```\n\n##### 错误控制机制\n\n**EOF - 立即终止执行**\n```go\n// 当遇到严重问题时，立即终止整个规则链\nreturn user, \"用户被禁用\", ruleengine.EOF\n```\n\n**FALLTHROUGH - 跳过当前规则继续执行**\n```go\n// 跳过当前规则，但继续执行后续规则\nreturn user, \"跳过此步骤\", ruleengine.FALLTHROUGH\n```\n\n#### 🌳 规则树结构\n\n除了线性的规则链，还支持树形结构的规则组织：\n\n##### 基础用法\n\n```go\ntype TestData struct {\n    Value int\n}\n\n// 创建规则节点\nleafNode := ruleengine.NewRuleNode[TestData](\n    func(data TestData, _ any) bool { return data.Value > 5 },\n    func(data TestData, _ any) (TestData, any, error) {\n        return TestData{Value: data.Value + 10}, \"处理完成\", nil\n    },\n)\n\n// 创建规则树\ntree := ruleengine.NewRuleTree[TestData](leafNode)\n\n// 执行规则树\nresult, info, err := tree.Run(TestData{Value: 3})\n```\n\n##### 复杂树形结构\n\n```go\n// 构建复杂的规则树\nrootNode := ruleengine.NewRuleNode[User](\n    func(user User, _ any) bool { return user.ID > 0 },\n    func(user User, _ any) (User, any, error) {\n        return user, \"用户ID验证通过\", nil\n    },\n)\n\n// 添加子节点\nageNode := ruleengine.NewRuleNode[User](\n    func(user User, _ any) bool { return user.Age > 0 },\n    func(user User, _ any) (User, any, error) {\n        return user, \"年龄验证通过\", nil\n    },\n)\n\nemailNode := ruleengine.NewRuleNode[User](\n    func(user User, _ any) bool { return user.Email != \"\" },\n    func(user User, _ any) (User, any, error) {\n        return user, \"邮箱验证通过\", nil\n    },\n)\n\n// 构建树形结构\nrootNode.AddChild(ageNode)\nrootNode.AddChild(emailNode)\n\ntree := ruleengine.NewRuleTree[User](rootNode)\n```\n\n#### 📝 复杂业务场景示例\n\n##### 用户注册验证流程\n\n```go\nfunc setupUserRegistrationEngine() *ruleengine.RuleEngine[User] {\n    engine := ruleengine.NewRuleEngine[User]()\n    \n    // 基础信息验证\n    engine.RegisterRule(\"validate_basic_info\",\n        func(user User, _ any) bool { return true },\n        func(user User, _ any) (User, any, error) {\n            if user.Name == \"\" {\n                return user, \"用户名不能为空\", ruleengine.EOF\n            }\n            if len(user.Name) < 2 {\n                return user, \"用户名太短\", ruleengine.EOF\n            }\n            return user, \"基础信息验证通过\", nil\n        },\n    )\n    \n    // 年龄检查\n    engine.RegisterRule(\"check_age\",\n        func(user User, _ any) bool { return true },\n        func(user User, _ any) (User, any, error) {\n            if user.Age < 13 {\n                return user, \"用户年龄过小\", ruleengine.EOF\n            } else if user.Age < 18 {\n                return user, \"未成年用户\", ruleengine.FALLTHROUGH\n            }\n            return user, \"成年用户\", nil\n        },\n    )\n    \n    // 成年用户身份验证（未成年用户会跳过）\n    engine.RegisterRule(\"adult_identity_check\",\n        func(user User, _ any) bool { return user.Age >= 18 },\n        func(user User, _ any) (User, any, error) {\n            if user.IDCard == \"\" {\n                return user, \"成年用户需要身份证\", ruleengine.EOF\n            }\n            return user, \"身份验证完成\", nil\n        },\n    )\n    \n    // 邮箱验证\n    engine.RegisterRule(\"validate_email\",\n        func(user User, _ any) bool { return user.Email != \"\" },\n        func(user User, _ any) (User, any, error) {\n            if !isValidEmail(user.Email) {\n                return user, \"邮箱格式错误\", ruleengine.EOF\n            }\n            return user, \"邮箱验证通过\", nil\n        },\n    )\n    \n    // 最终注册\n    engine.RegisterRule(\"complete_registration\",\n        func(user User, _ any) bool { return true },\n        func(user User, _ any) (User, any, error) {\n            user.ID = generateUserID()\n            user.CreatedAt = time.Now()\n            return user, \"注册完成\", nil\n        },\n    )\n    \n    // 构建注册流程链\n    engine.NewBuilder(\"user_registration\").\n        AddRule(\"validate_basic_info\").\n        AddRule(\"check_age\").\n        AddRule(\"adult_identity_check\").\n        AddRule(\"validate_email\").\n        AddRule(\"complete_registration\").\n        Build()\n    \n    return engine\n}\n\n// 使用示例\nfunc registerUser(userData User) {\n    engine := setupUserRegistrationEngine()\n    \n    result := engine.Execute(\"user_registration\", userData)\n    if result.Error != nil {\n        fmt.Printf(\"注册失败: %v\\n\", result.Error)\n        return\n    }\n    \n    fmt.Printf(\"注册成功: %+v\\n\", result.Data)\n    fmt.Printf(\"处理信息: %v\\n\", result.Result)\n}\n```\n\n##### 复杂执行场景分析\n\n```go\n// 执行结果分析：\n用户年龄 12: validate_basic_info(✅) → check_age(EOF 🛑) → 后续规则全部跳过\n用户年龄 16: validate_basic_info(✅) → check_age(FALLTHROUGH ⚡) → adult_identity_check(跳过) → validate_email(✅) → complete_registration(✅)\n用户年龄 25: validate_basic_info(✅) → check_age(✅) → adult_identity_check(✅) → validate_email(✅) → complete_registration(✅)\n```\n\n#### 🔄 批量执行\n\n```go\n// 批量执行多个规则链\nusers := []User{\n    {Name: \"张三\", Age: 25, Email: \"zhang@example.com\"},\n    {Name: \"李四\", Age: 17, Email: \"li@example.com\"},\n    {Name: \"王五\", Age: 30, Email: \"wang@example.com\"},\n}\n\nchains := []string{\"user_registration\", \"user_validation\"}\n\nfor _, user := range users {\n    results := engine.BatchExecute(chains, user)\n    for i, result := range results {\n        fmt.Printf(\"用户 %s 执行链 %s: \", user.Name, chains[i])\n        if result.Error != nil {\n            fmt.Printf(\"失败 - %v\\n\", result.Error)\n        } else {\n            fmt.Printf(\"成功 - %v\\n\", result.Result)\n        }\n    }\n}\n```\n\n#### 📚 API 参考\n\n##### 核心引擎方法\n\n**创建与配置：**\n- `NewRuleEngine[T]()` - 创建新的规则引擎\n- `RegisterRule(name, validFunc, execFunc)` - 注册规则\n- `AddMiddleware(middleware)` - 添加中间件\n\n**规则链构建：**\n- `NewBuilder(chainName)` - 创建规则链构建器\n- `AddRule(ruleName)` - 添加已注册的规则\n- `AddCustomRule(validFunc, execFunc)` - 添加临时规则\n- `Build()` - 构建规则链\n\n**执行方法：**\n- `Execute(chainName, data)` - 执行指定规则链\n- `BatchExecute(chainNames, data)` - 批量执行多个规则链\n\n##### 规则树方法\n\n**树结构构建：**\n- `NewRuleNode[T](validFunc, execFunc)` - 创建规则节点\n- `AddChild(childNode)` - 添加子节点\n- `AddChildren(childNodes...)` - 添加多个子节点\n\n**树执行：**\n- `NewRuleTree[T](rootNode)` - 创建规则树\n- `Run(data)` - 执行规则树\n- `ToQueue()` - 转换为队列形式\n\n##### 错误控制常量\n\n- `ruleengine.EOF` - 立即终止执行\n- `ruleengine.FALLTHROUGH` - 跳过当前规则继续执行\n\n##### 执行结果结构\n\n```go\ntype ExecuteResult[T any] struct {\n    Data   T           // 处理后的数据\n    Result any         // 执行结果信息\n    Error  error       // 错误信息\n}\n```\n\n#### ⚠️ 注意事项\n\n1. **系统要求**: 需要 Go 1.18+ (泛型支持)\n2. **线程安全**: 引擎实例支持并发访问\n3. **规则命名**: 建议使用 `动词_名词` 格式，如 `validate_email`\n4. **错误控制**: \n   - 使用 `EOF` 处理严重错误，立即终止\n   - 使用 `FALLTHROUGH` 跳过可选逻辑\n5. **性能优化**: \n   - 合理设计规则粒度，避免单个规则过于复杂\n   - 善用中间件处理横切关注点\n   - 规则链顺序影响性能，将高频失败的规则前置\n\n#### 🎯 最佳实践\n\n1. **单一职责**: 每个规则只处理一种业务逻辑\n2. **合理分层**: 基础验证 → 业务逻辑 → 数据处理 → 最终确认\n3. **错误处理**: 区分业务错误（FALLTHROUGH）和系统错误（EOF）\n4. **中间件使用**: 用于日志、监控、缓存等横切关注点\n5. **测试覆盖**: 为每个规则和规则链编写单元测试\n\n```go\n// 规则测试示例\nfunc TestValidateAgeRule(t *testing.T) {\n    engine := ruleengine.NewRuleEngine[User]()\n    \n    engine.RegisterRule(\"validate_age\",\n        func(user User, _ any) bool { return user.Age > 0 },\n        func(user User, _ any) (User, any, error) {\n            if user.Age < 18 {\n                return user, \"未成年\", ruleengine.FALLTHROUGH\n            }\n            return user, \"成年\", nil\n        },\n    )\n    \n    engine.NewBuilder(\"test_chain\").AddRule(\"validate_age\").Build()\n    \n    // 测试未成年用户\n    minorResult := engine.Execute(\"test_chain\", User{Age: 16})\n    assert.Equal(t, ruleengine.FALLTHROUGH, minorResult.Error)\n    assert.Equal(t, \"未成年\", minorResult.Result)\n    \n    // 测试成年用户\n    adultResult := engine.Execute(\"test_chain\", User{Age: 25})\n    assert.Nil(t, adultResult.Error)\n    assert.Equal(t, \"成年\", adultResult.Result)\n}\n```\n\n#### 📊 可视化流程图\n\n##### EOF 机制 - 立即终止执行\n\n```\n正常执行流程：\n┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐\n│   规则 A    │───▶│   规则 B    │───▶│   规则 C    │───▶│   规则 D    │\n│  (验证通过)  │    │  (验证通过)  │    │  (验证通过)  │    │  (验证通过)  │\n└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘\n       ✅               ✅               ✅               ✅\n\nEOF 终止流程：\n┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐\n│   规则 A    │───▶│   规则 B    │ ╳  │   规则 C    │    │   规则 D    │\n│  (验证通过)  │    │ (返回 EOF)  │    │  (未执行)   │    │  (未执行)   │\n└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘\n       ✅               🛑               ⭕               ⭕\n                   立即终止，后续规则不执行\n\n规则树中的 EOF：\n                    根节点\n                       │\n                   ┌───▼───┐\n                   │ 规则A │ ✅\n                   └───┬───┘\n                       │\n            ┌──────────┼──────────┐\n            ▼          ▼          ▼\n        ┌──────┐   ┌──────┐   ┌──────┐\n        │规则B1│   │规则B2│   │规则B3│\n        │ (EOF)│   │(未执行)│ │(未执行)│\n        └──────┘   └──────┘   └──────┘\n            🛑         ⭕         ⭕\n        \n        当B1返回EOF时，整个树立即终止\n        B2、B3 以及所有后续节点都不会执行\n```\n\n##### FALLTHROUGH 机制 - 跳过继续执行\n\n```\n正常执行流程：\n┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐\n│   规则 A    │───▶│   规则 B    │───▶│   规则 C    │───▶│   规则 D    │\n│  (验证通过)  │    │  (验证通过)  │    │  (验证通过)  │    │  (验证通过)  │\n└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘\n       ✅               ✅               ✅               ✅\n\nFALLTHROUGH 跳过流程：\n┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐\n│   规则 A    │───▶│   规则 B    │~~~▶│   规则 C    │───▶│   规则 D    │\n│  (验证通过)  │    │(FALLTHROUGH)│    │  (验证通过)  │    │  (验证通过)  │\n└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘\n       ✅               ⚡               ✅               ✅\n                   跳过但继续执行后续规则\n\n规则树中的 FALLTHROUGH：\n                      根节点\n                         │\n                     ┌───▼───┐\n                     │ 规则A │ ✅\n                     └───┬───┘\n                         │\n              ┌──────────┼──────────┐\n              ▼          ▼          ▼\n          ┌──────┐   ┌──────┐   ┌──────┐\n          │规则B1│   │规则B2│   │规则B3│\n          │(FALL)│   │ ✅   │   │ ✅   │\n          └──┬───┘   └──┬───┘   └──┬───┘\n             │⚡       │        │\n             ▼          ▼          ▼\n          ┌──────┐   ┌──────┐   ┌──────┐\n          │规则C1│   │规则C2│   │规则C3│\n          │(跳过) │   │ ✅   │   │ ✅   │\n          └──────┘   └──────┘   └──────┘\n             ⭕\n        \n        当B1返回FALLTHROUGH时：\n        - B1的子节点C1被跳过\n        - B2、B3 继续正常执行\n        - C2、C3 继续正常执行\n```\n\n<hr>\n\n## 💡 最佳实践\n\n### 🚀 性能优化建议\n\n<details>\n<summary><b>🌊 流式处理性能优化</b></summary>\n\n- **合理使用并行流**：大数据集(>1000元素)时启用`Parallel()`\n- **避免频繁装箱**：使用具体类型而非interface{}\n- **链式操作排序**：先Filter再Map，减少处理元素数量\n\n```go\n// ✅ 推荐：先过滤再处理\nstream.ToStream(&data).\n    Filter(func(item Item) bool { return item.IsValid() }).  // 先减少数据量\n    Map(func(item Item) ProcessedItem { return item.Process() }).\n\tToList()\n\n// ❌ 避免：先处理再过滤\nstream.ToStream(&data).\n    Map(func(item Item) ProcessedItem { return item.Process() }).  // 处理所有数据\n    Filter(func(item ProcessedItem) bool { return item.IsValid() }). // 再过滤\n\tToList()\n```\n</details>\n\n<details>\n<summary><b>📚 Optional 容器最佳实践</b></summary>\n\n- **避免嵌套Optional**：不要创建`Optional[Optional[T]]`\n- **使用类型安全的MapTyped**：避免类型断言错误\n- **合理使用OrElsePanic**：仅在确定不会为空时使用\n\n```go\n// ✅ 推荐：使用MapTyped进行类型安全转换\nresult := optional.MapTyped(optional.Of(\"  hello  \"), strings.TrimSpace).\n    Filter(func(s string) bool { return len(s) > 0 }).\n    OrElse(\"默认值\")\n\n// ❌ 避免：使用Map需要类型断言\nresult := optional.Of(\"  hello  \").\n    Map(func(s any) any { return strings.TrimSpace(s.(string)) }). // 需要断言\n    OrElse(\"默认值\")\n```\n</details>\n\n<details>\n<summary><b>⚡ 规则引擎最佳实践</b></summary>\n\n- **规则粒度控制**：单个规则只处理一种业务逻辑\n- **合理使用中间件**：用于日志、监控，避免业务逻辑\n- **错误控制策略**：EOF用于严重错误，FALLTHROUGH用于跳过逻辑\n\n```go\n// ✅ 推荐：单一职责的规则\nengine.RegisterRule(\"validate_email\",\n    func(user User, _ any) bool { return user.Email != \"\" },\n    func(user User, _ any) (User, any, error) {\n        if !isValidEmail(user.Email) {\n            return user, \"邮箱格式错误\", ruleengine.EOF\n        }\n        return user, \"邮箱验证通过\", nil\n    },\n)\n\n// ❌ 避免：复杂的多职责规则\nengine.RegisterRule(\"validate_user\",  // 太宽泛\n    func(user User, _ any) bool { return true },\n    func(user User, _ any) (User, any, error) {\n        // 验证邮箱、手机、身份证等多种逻辑混合\n        // 违反单一职责原则\n    },\n)\n```\n</details>\n\n<details>\n<summary><b>🌐 网络请求最佳实践</b></summary>\n\n- **设置合理的超时**：避免请求hang住\n- **使用链式构建**：提高代码可读性\n- **正确处理错误**：检查响应状态和错误\n\n```go\n// ✅ 推荐写法：完整的错误处理\nclient := remote.NewRemoteRequest(\"https://api.example.com\").\n    HttpClient(resty.New().SetTimeout(30*time.Second))\n\nvar result ApiResponse\nresp, err := client.\n    Headers(map[string]string{\"Authorization\": \"Bearer \" + token}).\n    QueryParam(map[string]string{\"page\": \"1\"}).\n    Method(\"GET\").\n    Url(\"/api/data\").\n    Build(&result)\n\nif err != nil {\n    log.Printf(\"请求失败: %v\", err)\n    return\n}\n\n// 检查业务逻辑错误\nif result.Code != 0 {\n    log.Printf(\"业务错误: %s\", result.Message)\n    return\n}\n```\n</details>\n\n<hr>\n\n## 👥 贡献指南\n\n我们热烈欢迎社区贡献！无论是报告问题、提出建议，还是提交代码，都对项目的发展很有帮助。\n\n### 🚀 如何参与\n\n<table>\n  <tr>\n    <td><b>🐛 报告问题</b></td>\n    <td>发现Bug或有改进建议？请在 <a href=\"https://github.com/karosown/katool-go/issues\">Issues</a> 中提交</td>\n  </tr>\n  <tr>\n    <td><b>✨ 贡献代码</b></td>\n    <td>提交新功能或修复，遵循下面的开发流程</td>\n  </tr>\n  <tr>\n    <td><b>📚 完善文档</b></td>\n    <td>改进文档、添加示例或翻译</td>\n  </tr>\n  <tr>\n    <td><b>🔧 性能优化</b></td>\n    <td>提升代码性能和质量</td>\n  </tr>\n</table>\n\n### 📝 开发流程\n\n1. **Fork 本仓库**\n   ```bash\n   git clone https://github.com/your-username/katool-go.git\n   cd katool-go\n   ```\n\n2. **创建特性分支**\n   ```bash\n   git checkout -b feature/amazing-feature\n   # 或\n   git checkout -b fix/bug-description\n   ```\n\n3. **开发和测试**\n   ```bash\n   # 运行测试确保不破坏现有功能\n   go test ./...\n   \n   # 运行性能测试\n   go test -bench=. ./...\n   \n   # 检查代码格式\n   go fmt ./...\n   go vet ./...\n   ```\n\n4. **提交更改**\n   ```bash\n   git add .\n   git commit -m \"feat: 添加新的流式处理功能\"\n   # 或\n   git commit -m \"fix: 修复并发访问问题\"\n   ```\n\n5. **推送和创建PR**\n   ```bash\n   git push origin feature/amazing-feature\n   ```\n   然后在GitHub上创建 Pull Request\n\n### ✅ 代码规范\n\n请确保您的代码符合以下要求：\n\n- **✅ 通过所有测试**：`go test ./...` 无错误\n- **📏 遵循Go规范**：使用 `go fmt`、`go vet` 检查\n- **📝 添加文档**：公开函数和结构体需要有注释\n- **🧪 包含测试**：新功能需要有对应的测试用例\n- **⚡ 性能考虑**：避免明显的性能问题\n\n### 📋 提交信息规范\n\n使用以下格式的提交信息：\n\n```\ntype(scope): 简短描述\n\n详细描述（可选）\n\nCloses #issue_number\n```\n\n**类型说明：**\n- `feat`: 新功能\n- `fix`: Bug修复\n- `docs`: 文档更新\n- `style`: 代码格式调整\n- `refactor`: 代码重构\n- `perf`: 性能优化\n- `test`: 测试相关\n- `chore`: 构建或工具相关\n\n**示例：**\n```\nfeat(stream): 添加并行流处理支持\n\n- 新增 Parallel() 方法启用并行处理\n- 优化大数据集的处理性能\n- 添加相关测试用例\n\nCloses #123\n```\n\n### 🔍 代码审查\n\n我们会仔细审查每个PR，确保：\n\n- 代码质量和性能\n- 测试覆盖率\n- 文档完整性\n- 与现有架构的兼容性\n\n### 🆘 获取帮助\n\n如果您在贡献过程中遇到问题：\n\n- 查看现有的 [Issues](https://github.com/karosown/katool-go/issues)\n- 阅读项目文档和示例\n- 在 Issue 中提问或讨论\n\n<hr>\n\n## 📄 许可证\n\nKatool-Go 采用 **MIT 许可证**。详情请参见 [LICENSE](LICENSE) 文件。\n\n### 📜 许可证摘要\n\n- ✅ **商业使用**：可用于商业项目\n- ✅ **修改**：可以修改源代码\n- ✅ **分发**：可以分发原版或修改版\n- ✅ **私用**：可用于私人项目\n- ❗ **责任**：作者不承担任何责任\n- ❗ **保证**：不提供任何保证\n\n### 🤝 致谢\n\n感谢所有为 Katool-Go 做出贡献的开发者和用户！\n\n特别感谢以下开源项目：\n- [Go 官方团队](https://golang.org/) - 提供优秀的编程语言\n- [resty](https://github.com/go-resty/resty) - HTTP客户端库\n- [rod](https://github.com/go-rod/rod) - Chrome控制库\n- [jieba](https://github.com/yanyiwu/gojieba) - 中文分词库\n- [logrus](https://github.com/sirupsen/logrus) - 日志库\n\n---\n\n<div align=\"center\">\n  <sub>Built with ❤️ by <a href=\"https://github.com/karosown\">Karosown Team</a></sub>\n  <br>\n  <sub>⭐ 如果这个项目对您有帮助，请给我们一个Star！</sub>\n</div>"
